# -*- mode: sh; sh-basic-offset: 3; indent-tabs-mode: nil; -*-
# vim: set filetype=sh sw=3 sts=3 expandtab autoindent:
#
# Copyright 2016 Benjamin Maisonnas <ben@wainei.net>
#
# This work is free. You can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#

HELPERS="$HELPERS borg:deduplicated_archive_based_backup"

declare -a borg_includes
declare -a borg_excludes

# FUNCTIONS

do_borg_host_includes() {
   set -o noglob
   # choose the files to backup
   REPLY=
   while [ -z "$REPLY" ]; do
      formBegin "$borg_title - host system: includes"
         for ((i=0; i < ${#borg_includes[@]} ; i++)); do
            formItem include ${borg_includes[$i]}
         done
         formItem include
         formItem include
         formItem include
         formItem include
         formItem include
         formItem include
         formItem include
         formItem include
      formDisplay
      [ $? = 0 ] || return
      unset borg_includes
      borg_includes=($REPLY)
   done
   set +o noglob
}

do_borg_excludes() {
   set -o noglob
   formBegin "$borg_title: host system: excludes"
     for ((i=0; i < ${#borg_excludes[@]} ; i++))
     do
       formItem exclude ${borg_excludes[$i]}
     done
     formItem exclude
     formItem exclude
     formItem exclude
     formItem exclude
     formItem exclude
     formItem exclude
     formItem exclude
     formItem exclude
   formDisplay
   [ $? = 0 ] || return
   unset borg_excludes
   borg_excludes=($REPLY)
   set +o noglob
}

do_borg_src() {
   do_borg_host_includes
   [ $? = 0 ] || return 1

   do_borg_excludes
   [ $? = 0 ] || return 1

   _src_done="(DONE)"
   setDefault dest
}

do_borg_dest() {
   set -o noglob

   radioBox "$borg_protocol" "Connection protocol for remote repositories" \
   "ssh" "use ssh as remote shell" on \
   "sftp" "use sftp as alternative to a remote shell" off
   [ $? = 1 ] && return;
   result="$REPLY"
   borg_protocol="$result"

   declare -a tmp_array
   REPLY=
   while [ -z "$REPLY" -o -z "$borg_directory" -o -z "$borg_host" \
   -o -z "$borg_port" -o -z "$borg_user" -o -z "$borg_id_file" -o -z "$borg_archive" -o -z "$borg_compression" ]
   do
     formBegin "$borg_title - destination"
        formItem "directory" "$borg_directory"
        formItem "host" "$borg_host"
        formItem "port" "$borg_port"
        formItem "user" "$borg_user"
        formItem "id_file" "$borg_id_file"
        formItem "archive_name" "$borg_archive"
        formItem "compression" "$borg_compression"

        formDisplay
     [ $? = 0 ] || return
     tmp_array=($REPLY)
     borg_directory=${tmp_array[0]}
     borg_host=${tmp_array[1]}
     borg_port=${tmp_array[2]}
     borg_user=${tmp_array[3]}
     borg_id_file=${tmp_array[4]}
     borg_archive=${tmp_array[5]}
     borg_compression=${tmp_array[6]}
  done
  set +o noglob

  _dest_done="(DONE)"
  setDefault conn
}

do_borg_enc() {
   radioBox "$borg_title" "Encryption mode" \
       "none"     "no encryption and no authentication" on \
       "repokey"  "encryption with a passphrase" off
   [ $? = 1 ] && return;
   borg_encryption="$REPLY"

   if [ "$borg_encryption" = "repokey" ]; then
      local question="Enter the passphrase needed to encrypt/decrypt the repository:"
      REPLY=
      while [ -z "$REPLY" -o -z "$borg_passphrase" ]; do
         passwordBox "$borg_title - " "$question"
         [ $? = 0 ] || return 1
         borg_passphrase="$REPLY"
      done
   fi

  _enc_done="(DONE)"
  setDefault prune
}

do_borg_local_dir() {
   local dir_status="ok"

   IFS=$' \t\n'
   if [ "$_dest_done" = "" ]; then
      msgBox "$borg_title: error" "You must first configure the destination."
      return 1
   fi

   echo "Testing to see if the borg backup directory exists and is writable"
   if [ test -d "$borg_directory" ]; then
      if [ test -w "$borg_directory" ]; then
         msgBox "destination directory is not writable!" "The destination directory is not writable by the user you specified. Please fix the permissions on the directory and then try again."
         dir_status=failed
      fi
   else
      booleanBox "Destination does not exist" "The destination backup directory does not exist, do you want me to create it for you?"
      if [ $? = 0 ]; then
         if mkdir -p "$borg_directory"; then
            msgBox "$borg_title: success" "Creation of the destination directory was a success!"
         else
            msgBox "$borg_title: error" "Creation of the destination directory failed, check the directory permissions."
            dir_status=failed
         fi
      fi
   fi

   [ "$dir_status" = "ok" ] || return 1
}

do_borg_ssh_con() {
   local remote_status="ok"

   IFS=$' \t\n'
   if [ "$_dest_done" = "" ]; then
      msgBox "$borg_title: error" "You must first configure the destination."
      return 1
   elif [ "$borg_user" = "" ]; then
      msgBox "$borg_title: error" "You must first configure the destination user."
      return 1
   elif [ "$borg_host" = "" ]; then
      msgBox "$borg_title: error" "You must first configure the destination host."
      return 1
   else
      msg='This step will create a ssh key for the local root user with no passphrase (if one does not already exist), '\
'and attempt to copy '"${borg_user}'s"' public ssh key to authorized_keys file of '"$borg_user@$borg_host"'. '\
'This will allow the local root to make unattended backups to '"$borg_user@$borg_host.\n\n\n"
      booleanBox "$borg_title" "${msg}"
      if [ $? -eq 0 ]; then
         msg="${msg}Specify an optional comment for the keypair:"
         inputBox "$borg_title" "${msg}"
         [ $? = 0 ] || return 1
         key_comment=$REPLY
      fi
   fi
   if [ $? -eq 0 ]; then
      echo "Creating local rsa keypair for user..."
      if [ ! -f "$borg_id_file" ]; then
        if [ "$key_comment" = "" ]; then
            ssh-keygen -t rsa -b 4096 -f "$borg_id_file" -N ""
        else
            ssh-keygen -t rsa -b 4096 -f "$borg_id_file" -N "" -C "$key_comment"
        fi
      fi
   fi

   if [ "$borg_protocol" == "ssh" ]; then
      ssh -o PreferredAuthentications=publickey -i $borg_id_file $borg_host -p $borg_port -l $borg_user "exit" 2> /dev/null
      if [ $? -ne 0 ]; then
         echo "Copying root's public ssh key to authorized_keys of $borg_user@$borg_host. When prompted, specify the password for user $borg_user@$borg_host."
         if ! ssh-copy-id -i "${borg_id_file}.pub" -p $borg_port $borg_user@$borg_host ; then
            echo "FAILED: Couldn't copy root's public ssh key to authorized_keys of $borg_user@$borg_host."
            ssh -p $borg_port $borg_user@$borg_host 'test -w .ssh || test -w .'
            result=$?
            echo "Hit return to continue."
            read
            case $result in
               0 )   msgBox "$borg_title: success" "Directories are writable." ;;
               1 )   msgBox "$borg_title: error" "Connected successfully to $borg_user@$borg_host, but unable to write. Check ownership and modes of ~$borg_user on $borg_host." ;;
               255 ) msgBox "$borg_title: error" "Failed to connect to $borg_user@$borg_host. Check hostname, username, and password. Also, make sure sshd is running on the destination host." ;;
               * )   msgBox "$borg_title: error" "Unexpected error (return code ${result})." ;;
            esac
            return
         else
            echo "Done. Hit return to continue"
            read
         fi
      else
         echo "$borg_user's public key is already in authorized_keys of $borg_user@$borg_host."
         echo "Hit return to continue."
         read
      fi
   fi

   if [ "$borg_protocol" = "sftp" ]; then

      # initial creation of a temporary directory and variables for the authorized_keys and the
      # master ssh connection
      SCRATCH_DIR=$(mktemp --dry-run borg-helper-temp.XXXXXXXXXX)
      if test $? -ne 0 || test "x$SCRATCH_DIR" = "x" ; then
         printf "%s ERROR: mktemp failed\n" >&2
         exit 1
      fi
      mkdir $SCRATCH_DIR
      chmod 700 $SCRATCH_DIR
      if [ -d "$SCRATCH_DIR" ]; then
         SCRATCH_CLEANUP="rm -rf \"$SCRATCH_DIR\""
         trap "$SCRATCH_CLEANUP" EXIT TERM INT QUIT
      else
         printf '%s: ERROR: Required scratch directory (%s) was not created\n' "$SCRATCH_DIR" >&2
         exit 1
      fi

      # path to the temporary files for the ssh socket and the authorized key file of the remote machine
      KEYS_TEMPFILE=$SCRATCH_DIR/authorized_keys
      SHARED_CONN=$SCRATCH_DIR/master-conn

      # test if the public key is already in the remote server's authorized_keys
      echo "exit" | sftp -P $borg_port -o "PasswordAuthentication=no" -o "IdentityFile=${borg_id_file}" $borg_user@$borg_host
      if [ $? -eq 0 ]; then
         echo "$borg_user's public key is already in authorized_keys of $borg_user@$borg_host."
         echo "Done. Hit return to continue."
         read
      else

         # open a ssh tunnel to pipe sftp traffic through and prepare cleaning up
         ssh -p ${borg_port} -f -N -M -o ControlMaster=auto -o "ControlPath=${SHARED_CONN}" ${borg_user}@${borg_host}
         CLEANUP="ssh -o "ControlPath=${SHARED_CONN}" -o ControlMaster=auto -O exit 'ignored' >/dev/null 2>&1 ; $SCRATCH_CLEANUP"
         trap "$CLEANUP" EXIT TERM INT QUIT

         # use sftp with -b - to get the cmd's to execute on the remote machine via stdin
         sftp -b - -o "ControlPath=${SHARED_CONN}" "ignored" <<-EOF
            -get .ssh/authorized_keys $KEYS_TEMPFILE
EOF
         # add a newline or create file if it's missing
         [ -z "$(tail -1c $KEYS_TEMPFILE 2>/dev/null)" ] || echo >> $KEYS_TEMPFILE
         # append the keys being piped in here
         cat "${borg_id_file}.pub" >> $KEYS_TEMPFILE
         sftp -b - -o "ControlPath=${SHARED_CONN}" "ignored" <<-EOF || return 1
            -mkdir .ssh
            chmod 700 .ssh
            put $KEYS_TEMPFILE .ssh/authorized_keys
            chmod 600 .ssh/authorized_keys
EOF
      fi
   fi

   # test to see if the remote borg backup directory exists and is writable
   echo "Testing to see if remote borg backup directory exists and is writable"
   if [ "$borg_protocol" == "ssh" ]; then
      ssh -p $borg_port -i $borg_id_file $borg_user@$borg_host "test -d ${borg_directory}"
      if [ $? = 0 ]; then
         ssh -p $borg_port -i $borg_id_file $borg_user@$borg_host "test -w $borg_directory"
         if [ $? != 0 ]; then
            msgBox "destination directory is not writable!" "The remote destination directory is not writable by the user you specified. Please fix the permissions on the directory and then try again."
            remote_status=failed
         else
            result=0
         fi
      else
         booleanBox "Remote directory does not exist" "The destination backup directory does not exist, do you want me to create it for you?"
         if [ $? = 0 ]; then
            ssh -p $borg_port -i $borg_id_file $borg_user@$borg_host "mkdir -p ${borg_directory}"
            result=$?
         fi
      fi
   fi

   # test the read/write access on the remote repository for sftp
   if [ "$borg_protocol" == "sftp" ]; then
     if [ ! -e "$SHARED_CONN" ]; then
         ssh -p ${borg_port} -f -N -M -o ControlMaster=auto -o "ControlPath=${SHARED_CONN}" ${borg_user}@${borg_host}
         SSH_CLEANUP="ssh -o "ControlPath=${SHARED_CONN}" -o ControlMaster=auto -O exit 'ignored' >/dev/null 2>&1"
         trap "$SSH_CLEANUP" EXIT TERM INT QUIT
     fi
       echo "ls $borg_directory" | sftp -b - -o "ControlMaster=auto" -o -S $SHARED_CONN ${borg_user}@${borg_host}
       if [ $? -eq 0 ]; then
           touch /tmp/foo.bar
           output=$(echo "put /tmp/foo.bar ${borg_directory}" | sftp -o "ControlMaster=auto" -o "ControlPath=${SHARED_CONN}" ${borg_user}@${borg_host})
           if [ $? -eq 0 ]; then
              echo "${output}" | grep -E "remote open.+Permission denied"
                 if [ $? -eq 0 ]; then
                      msgBox "destination directory is not writable!" "The remote destination directory is not writable by the user you specified. Please fix the permissions on the directory and then try again."
                      result=1
                 else
                    result=0
                 fi
           else
             msgBox "The sftp connection couldn't be established."
             result=255
           fi
           echo "rm ${borg_directory}/foo.bar" | sftp -o "ControlMaster=auto" -o "ControlPath=${SHARED_CONN}" ${borg_user}@${borg_host}
       else
         booleanBox "Remote directory does not exist" "The destination backup directory does not exist, do you want me to create it for you?"
         if [ $? -eq 0 ]; then
             echo "exit" | sftp -b - -o "ControlMaster=auto" -o "ControlPath=${SHARED_CONN}" ${borg_user}@${borg_host}
             if [ $? -eq 255 ]; then
                 result=255
             else
               echo "mkdir ${borg_directory}" | sftp -b - -o "ControlMaster=auto" -o "ControlPath=${SHARED_CONN}" ${borg_user}@${borg_host}
               if [ $? -eq 0 ]; then
                 result=0
               else
                 output=$(echo "mkdir ${borg_directory}" | sftp -b - -o "ControlMaster=auto" -o "ControlPath=${SHARED_CONN}" ${borg_user}@${borg_host})
                   if echo "$output" | grep "remote open.+Permission denied" ; then
                     result=1
                   fi
                   # if the directory already exists SFTP returns "Couldn't create directory: Failure"
                   if echo "$output" | grep "Couldn't create directory" ; then
                     result=0
                   else
                     result=999999
                   fi
               fi
             fi
         fi
       fi
   fi

   case $result in
             0) msgBox "$borg_title: success" "Directory already exists or was successfully created!";;
             1) msgBox "$borg_title: error" "Connected successfully to $borg_user@$borg_host, but was unable to create the destination directory, check the directory permissions."
               remote_status=failed;;
             255) msgBox "$borg_title: error" "Failed to connect to $borg_user@$borg_host. Check hostname, username, and password. Also, make sure sshd is running on the destination host."
               remote_status=failed;;
             *) msgBox "$borg_title: error" "Unexpected error."
               remote_status=failed;;
   esac

   [ "$remote_status" = "ok" ] || return 1
}

do_borg_con() {
   echo "Checking for local install of borg"
   which borg
   if [ $? != 0 ]; then
      msgBox "$borg_title: error" "borg executable not found, please install borg ($borg_docs/installation.html)."
      return
   fi

   if [ "$borg_host" != "localhost" ]; then
      do_borg_ssh_con
   else
      do_borg_local_dir
   fi

   [ $? = 0 ] || return

   echo "SUCCESS: Everything looks good!"
   echo "Hit return to continue."
   read

   _con_done="(DONE)"
   setDefault enc
}

do_borg_prune() {
   radioBox "$borg_title" "pruning (how many backups to keep" \
       "yes" "regularly prune old backups" on \
       "no"  "keep all backups" off
   [ $? = 1 ] && return;
   borg_prune="$REPLY"

   if [ "$borg_prune" = "yes" ]; then
      declare -a tmp_array
      set -o noglob
      REPLY=
      formBegin "$borg_title - keep all backups made within this number of days"
         formItem "keep" "$borg_keep"
         formDisplay

      [ $? = 0 ] || return
      tmp_array=($REPLY)
      borg_keep=${tmp_array[0]}

      set +o noglob
   fi

  _prune_done="(DONE)"
   setDefault finish
}

do_borg_finish() {
   get_next_filename $configdirectory/90.borg
   cat > $next_filename <<EOF
## for more options see
## - example.borg
## - $borg_docs

[source]
EOF
   ## includes ##
   set -o noglob
   for ((i=0; i < ${#borg_includes[@]} ; i++)); do
      echo "include = ${borg_includes[$i]}" >> $next_filename
   done
   set +o noglob

   ## excludes ##
   set -o noglob
   for ((i=0; i < ${#borg_excludes[@]} ; i++)); do
     echo exclude = ${borg_excludes[$i]} >> $next_filename
   done
   set +o noglob
   cat >> $next_filename <<EOF

## for more info see : borg prune -h
prune = $borg_prune
keep = "${borg_keep}d"

[dest]
directory = $borg_directory
host = $borg_host
port = $borg_port
user = $borg_user
id_file = $borg_id_file
archive = $borg_archive
compression = $borg_compression
encryption = $borg_encryption
passphrase = $borg_passphrase
EOF

   chmod 600 $next_filename
}

borg_main_menu() {
   while true; do
      srcitem="choose files to include & exclude $_src_done"
      destitem="configure backup destination $_dest_done"
      conitem="test connection and destination dir $_con_done"
      encitem="configure encryption mode $_enc_done"
      pruneitem="configure pruning (optional) $_prune_done"
      menuBox "$borg_title" "choose a step:" \
         src "$srcitem" \
         dest "$destitem" \
         conn "$conitem" \
         enc "$encitem" \
         prune "$pruneitem" \
         finish "finish and create config file"
      [ $? = 0 ] || return
      result="$REPLY"
      case "$result" in
         "src") do_borg_src;;
         "dest") do_borg_dest;;
         "conn") do_borg_con;;
         "enc") do_borg_enc;;
         "prune") do_borg_prune;;
         "finish")
            if [[ "$_con_done$_dest_done$_enc_done$_src_done" != "(DONE)(DONE)(DONE)(DONE)" ]]; then
               msgBox "$borg_title" "You cannot create the configuration file until mandatory steps are completed."
            else
               do_borg_finish
               return
            fi
            ;;
      esac
   done
}

borg_wizard() {
   # Global variables
   borg_title="borg action wizard"
   borg_docs="http://borgbackup.readthedocs.io/en/stable"

   _src_done=
   _dest_done=
   _enc_done=
   _con_done=

   borg_directory=/backup/$(hostname)
   borg_user=root
   borg_host=localhost
   borg_port=22
   borg_id_file=/root/.ssh/id_rsa
   borg_archive='{now:%Y-%m-%dT%H:%M:%S}'
   borg_compression=lz4
   borg_encryption=none
   borg_passphrase=
   borg_keep=30
   borg_init_options=

   # Global variables whose '*' shall not be expanded
   set -o noglob
   borg_includes=(/var/spool/cron/crontabs /var/backups /etc /root /home /usr/local/*bin)
   borg_excludes=(/home/*/.gnupg /home/*/.local/share/Trash /home/*/.Trash /home/*/.thumbnails)
   set +o noglob

   borg_main_menu
}
